name: Backend CI/CD (prod)

on:
  push:
    branches: ["main"]
    paths:
      - "backend/**"
      - "deploy/backend/**"
      - ".github/workflows/backend-ci-cd.yml"
  workflow_dispatch:
    inputs:
      image:
        description: "이미지 태그 또는 풀 경로 (예: ghcr.io/owner/ibmall-backend:<tag>)"
        required: true
        type: string

jobs:
  build-and-deploy:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17 (Gradle cache)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: gradle

      - name: Build (backend)
        working-directory: backend
        run: |
          chmod +x gradlew
          ./gradlew clean bootJar -x test

      - name: Set image tags
        id: tags
        run: |
          OWNER="${{ secrets.GHCR_USER }}"
          OWNER_LC="$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')"
          echo "IMAGE=ghcr.io/${OWNER_LC}/ibmall-backend:${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "IMAGE_MAIN=ghcr.io/${OWNER_LC}/ibmall-backend:main" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USER }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Build & Push Docker image
        run: |
          docker build -f backend/Dockerfile -t "${{ steps.tags.outputs.IMAGE }}" backend
          docker tag "${{ steps.tags.outputs.IMAGE }}" "${{ steps.tags.outputs.IMAGE_MAIN }}"
          docker push "${{ steps.tags.outputs.IMAGE }}"
          docker push "${{ steps.tags.outputs.IMAGE_MAIN }}"

      # ── AWS 자격 구성 ────────────────────────────────────────────────────────
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      # ── 현재 활성/유휴 색상 감지 (리스너 기본 작업 기준) ─────────────────────
      - name: Detect active color (listener default action)
        id: color
        env:
          TG_BLUE_ARN:  ${{ secrets.TG_BLUE_ARN }}
          TG_GREEN_ARN: ${{ secrets.TG_GREEN_ARN }}
          LISTENER_ARN: ${{ secrets.LISTENER_ARN }}
        run: |
          set -euo pipefail
          ACTIVE_TG=$(aws elbv2 describe-listeners --listener-arn "$LISTENER_ARN" \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' --output text)
          if [ -z "$ACTIVE_TG" ] || [ "$ACTIVE_TG" = "None" ]; then
            ACTIVE_TG=$(aws elbv2 describe-listeners --listener-arn "$LISTENER_ARN" \
              --query 'Listeners[0].DefaultActions[0].ForwardConfig.TargetGroups[0].TargetGroupArn' --output text)
          fi
          echo "ACTIVE_TG=$ACTIVE_TG"
          if [ "$ACTIVE_TG" = "$TG_BLUE_ARN" ]; then
            echo "active=blue"  >> $GITHUB_OUTPUT
            echo "idle=green"   >> $GITHUB_OUTPUT
            echo "idle_tg=$TG_GREEN_ARN" >> $GITHUB_OUTPUT
          elif [ "$ACTIVE_TG" = "$TG_GREEN_ARN" ]; then
            echo "active=green" >> $GITHUB_OUTPUT
            echo "idle=blue"    >> $GITHUB_OUTPUT
            echo "idle_tg=$TG_BLUE_ARN" >> $GITHUB_OUTPUT
          else
            echo "Unknown active target group: $ACTIVE_TG"; exit 1
          fi

      # ── deploy.sh 배포 ───────────────────────────────────────────────────────
      - name: Ship backend deploy script via Bastion
        shell: bash
        run: |
          set -euo pipefail
          echo "${{ secrets.BASTION_KEY }}" > bastion.pem
          chmod 600 bastion.pem
          SSH_BASTION="${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}"
          APP_USER="${{ secrets.APP_USER }}"
          APP1="${{ secrets.APP1_HOST }}"
          APP2="${{ secrets.APP2_HOST }}"
          SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=20 -o ServerAliveCountMax=10 -o TCPKeepAlive=yes -o IdentitiesOnly=yes"

          # 2nd hop key to bastion
          scp $SSH_OPTS -i bastion.pem bastion.pem "$SSH_BASTION":/tmp/app.pem
          ssh $SSH_OPTS -i bastion.pem "$SSH_BASTION" "chmod 600 /tmp/app.pem"

          # deploy.sh → bastion
          scp $SSH_OPTS -i bastion.pem ./deploy/backend/deploy.sh "$SSH_BASTION":/tmp/deploy_back.sh

          # bastion → each app server
          for HOST in "$APP1" "$APP2"; do
            ssh $SSH_OPTS -i bastion.pem "$SSH_BASTION" \
              "scp $SSH_OPTS -i /tmp/app.pem /tmp/deploy_back.sh ${APP_USER}@${HOST}:/tmp/deploy_back.sh && \
               ssh $SSH_OPTS -i /tmp/app.pem ${APP_USER}@${HOST} \
                 'sudo mkdir -p /home/ubuntu/deploy/backend && \
                  sudo mv /tmp/deploy_back.sh /home/ubuntu/deploy/backend/deploy.sh && \
                  sudo chmod +x /home/ubuntu/deploy/backend/deploy.sh'"
          done

      # ── 유휴 색상으로 두 앱서버 배포 ────────────────────────────────────────
      - name: Deploy idle color to app servers
        env:
          IMAGE: ${{ steps.tags.outputs.IMAGE }}
          GHCR_USER: ${{ secrets.GHCR_USER }}
          GHCR_PAT:  ${{ secrets.GHCR_PAT }}
          IDLE:      ${{ steps.color.outputs.idle }}
        shell: bash
        run: |
          set -euo pipefail
          echo "${{ secrets.BASTION_KEY }}" > bastion.pem
          chmod 600 bastion.pem
          SSH_BASTION="${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}"
          APP_USER="${{ secrets.APP_USER }}"
          APP1="${{ secrets.APP1_HOST }}"
          APP2="${{ secrets.APP2_HOST }}"
          SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=20 -o ServerAliveCountMax=10 -o TCPKeepAlive=yes -o IdentitiesOnly=yes"

          # ensure 2nd hop key exists on bastion
          scp $SSH_OPTS -i bastion.pem bastion.pem "$SSH_BASTION":/tmp/app.pem
          ssh $SSH_OPTS -i bastion.pem "$SSH_BASTION" "chmod 600 /tmp/app.pem"

          for HOST in "$APP1" "$APP2"; do
            ssh $SSH_OPTS -i bastion.pem "$SSH_BASTION" \
              "ssh $SSH_OPTS -i /tmp/app.pem ${APP_USER}@${HOST} \
               'set -euo pipefail;
                echo \"${GHCR_PAT}\" | sudo docker login ghcr.io -u \"${GHCR_USER}\" --password-stdin;
                ENV_FILE=/home/ubuntu/env/backend.prod DATA_ROOT=/home/ubuntu/upload SPRING_PROFILES_ACTIVE=prod \
                sudo /home/ubuntu/deploy/backend/deploy.sh \"${IMAGE}\" \"${IDLE}\"'"
          done


      # ── 유휴 TG 헬스 체크 완료까지 대기(두 인스턴스 모두) ───────────────────
      - name: Wait for idle target group healthy
        env:
          IDLE_TG_ARN: ${{ steps.color.outputs.idle_tg }}
        run: |
          set -euo pipefail
          deadline=$(( $(date +%s) + 180 ))
          while true; do
            states=$(aws elbv2 describe-target-health --target-group-arn "$IDLE_TG_ARN" \
              --query 'TargetHealthDescriptions[*].TargetHealth.State' --output text || true)
            echo "target states: $states"
            if [ -n "$states" ] && ! grep -qE '(initial|unhealthy|draining|unavailable)' <<< "$states"; then
              echo "Idle TG healthy"; break
            fi
            [ $(date +%s) -lt $deadline ] || { echo "Timeout waiting for healthy"; exit 1; }
            sleep 3
          done

      # ── 리스너 기본 작업을 유휴 TG로 스위치(= 활성 전환) ─────────────────────
      - name: Switch listener default action to idle color
        env:
          LISTENER_ARN: ${{ secrets.LISTENER_ARN }}
          IDLE_TG_ARN:  ${{ steps.color.outputs.idle_tg }}
        run: |
          set -euo pipefail
          aws elbv2 modify-listener --listener-arn "$LISTENER_ARN" \
            --default-actions 'Type=forward,ForwardConfig={"TargetGroups":[{"TargetGroupArn":"'"$IDLE_TG_ARN"'","Weight":1}]}'
          aws elbv2 describe-listeners --listener-arn "$LISTENER_ARN" \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' --output text || true

# ==== 스위치 후 이전색 컨테이너 정리(프리티어 메모리 확보)
      - name: Cleanup previous color containers (optional)
        env:
          ACTIVE: ${{ steps.color.outputs.active }}
        run: |
          set -euo pipefail
          echo "Cleaning old color: $ACTIVE"
          echo "${{ secrets.BASTION_KEY }}" > bastion.pem
          chmod 600 bastion.pem
          SSH_BASTION="${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}"
          APP_USER="${{ secrets.APP_USER }}"
          APP1="${{ secrets.APP1_HOST }}"
          APP2="${{ secrets.APP2_HOST }}"
          SSH_OPTS="-o StrictHostKeyChecking=no -o ServerAliveInterval=20 -o ServerAliveCountMax=10 -o TCPKeepAlive=yes -o IdentitiesOnly=yes"

          for H in "$APP1" "$APP2"; do
            ssh $SSH_OPTS -i bastion.pem "$SSH_BASTION" \
              "ssh $SSH_OPTS -i /tmp/app.pem ${APP_USER}@${H} \
               'sudo docker rm -f ibmall-backend-'"$ACTIVE"' || true; \
                 sudo docker rm -f ibmall-backend || true; \
                 sudo docker image prune -f || true'"
          done

  # ===== 수동 롤백(기본 작업 flip) =============================================
  rollback:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      - name: Flip listener to the other color
        env:
          TG_BLUE_ARN:  ${{ secrets.TG_BLUE_ARN }}
          TG_GREEN_ARN: ${{ secrets.TG_GREEN_ARN }}
          LISTENER_ARN: ${{ secrets.LISTENER_ARN }}
        run: |
          set -euo pipefail
          ACTIVE_TG=$(aws elbv2 describe-listeners --listener-arn "$LISTENER_ARN" \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' --output text)
          if [ "$ACTIVE_TG" = "$TG_BLUE_ARN" ]; then TARGET="$TG_GREEN_ARN"; else TARGET="$TG_BLUE_ARN"; fi
          aws elbv2 modify-listener --listener-arn "$LISTENER_ARN" \
            --default-actions Type=forward,ForwardConfig='{"TargetGroups":[{"TargetGroupArn":"'"$TARGET"'","Weight":1}]}'
          echo "Rolled over to $TARGET"
